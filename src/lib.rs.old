use std::{cell::RefCell, rc::Rc};

use rusty_boy_core::{gameboy::{self, Gameboy}, keypad::Key};
use wasm_bindgen::{prelude::*, Clamped};
use web_sys::{CanvasRenderingContext2d, GamepadEvent, ImageData};

const ROM_DATA: &[u8] = include_bytes!("..\\..\\..\\roms\\zelda.gb");

const ORIGINAL_WIDTH: u32 = 160;
const ORIGINAL_HEIGHT: u32 = 144;

const SCALE: u32 = 1;

const WIDTH: u32 = ORIGINAL_WIDTH * SCALE;
const HEIGHT: u32 = ORIGINAL_HEIGHT * SCALE;

#[wasm_bindgen]
extern "C" {
    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

fn get_key_from_code(code: u32) -> Option<Key> {
    match code {
        81 => Some(Key::Left),
        90 => Some(Key::Up),
        68 => Some(Key::Right),
        83 => Some(Key::Down),
        13 => Some(Key::A),
        32 => Some(Key::B),
        87 => Some(Key::Select),
        69 => Some(Key::Start),
        _ => None,
    }
}

#[wasm_bindgen(start)]
fn start() -> Result<(), JsValue> {
    console_error_panic_hook::set_once();

    let mut previous_buttons_state = Rc::new(RefCell::new([false; 8]));

    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id("canvas").unwrap();
    let canvas = canvas.dyn_into::<web_sys::HtmlCanvasElement>()?;

    let context = canvas
        .get_context("2d")?
        .unwrap()
        .dyn_into::<CanvasRenderingContext2d>()?;

    let data = ROM_DATA.to_vec();
    let gb = Gameboy::new_from_data(&data, true).expect("Error");
    let gb = Rc::new(RefCell::new(gb));
    // Request animation frame

    let gb_cloned_1 = Rc::clone(&gb);
    let on_key_down = Closure::wrap(Box::new(move |event: web_sys::KeyboardEvent| {
        let binary = event.key_code();
        if let Some(key) = get_key_from_code(binary) {
            gb_cloned_1
                .borrow_mut()
                .update_input(rusty_boy_core::keypad::KeyEvent::Press(key));
        }
    }) as Box<dyn FnMut(_)>);

    let gb_cloned_2 = Rc::clone(&gb);
    let on_key_up = Closure::wrap(Box::new(move |event: web_sys::KeyboardEvent| {
        let binary = event.key_code();
        if let Some(key) = get_key_from_code(binary) {
            gb_cloned_2
                .borrow_mut()
                .update_input(rusty_boy_core::keypad::KeyEvent::Release(key));
        }
    }) as Box<dyn FnMut(_)>);

    let event_target = web_sys::window().unwrap();
    event_target.set_onkeydown(Some(on_key_down.as_ref().unchecked_ref()));
    on_key_down.forget();

    let event_target = web_sys::window().unwrap();
    event_target.set_onkeyup(Some(on_key_up.as_ref().unchecked_ref()));
    on_key_up.forget();

    // Request animation frame
    let f: Rc<RefCell<Option<Closure<_>>>> = Rc::new(RefCell::new(None));
    let g: Rc<RefCell<Option<Closure<_>>>> = f.clone();

    let frame_duration = 1000.0 / 60.0; // 60 FPS

    let start_time = js_sys::Date::now();
    let mut previous_time = start_time;

    *g.borrow_mut() = Some(Closure::new(move || {
        let current_time = js_sys::Date::now();
        let elapsed_time = current_time - previous_time;

        if elapsed_time < frame_duration {
            request_animation_frame(f.borrow().as_ref().unwrap());
            return;
        }


        // Clear the screen
        gb.borrow_mut().run_frame();

        context.clear_rect(0.0, 0.0, WIDTH as f64, HEIGHT as f64);

        // Render the screen
        let borrowed = gb.borrow();
        let screen_data = borrowed.get_screen_data();
        let screen_data = rgb_to_rgba(screen_data);

        // Créer une copie des données
        //let screen_data_copy = screen_data.to_vec();

        let image_data =
            ImageData::new_with_u8_clamped_array_and_sh(Clamped(&screen_data), WIDTH, HEIGHT)
                .expect("Error");
        //console_log!("Screen data: {:?}", image_data.data());

        context
            .put_image_data(&image_data, 0.0, 0.0)
            .expect("Error");

        previous_time = current_time;
        request_animation_frame(f.borrow().as_ref().unwrap());
    }));

    request_animation_frame(g.borrow().as_ref().unwrap());

    Ok(())
}

fn request_animation_frame(f: &Closure<dyn FnMut()>) {
    web_sys::window()
        .expect("no global `window` exists")
        .request_animation_frame(f.as_ref().unchecked_ref())
        .expect("should register `requestAnimationFrame` OK");
}

fn rgb_to_rgba(rgb: &[u8]) -> Vec<u8> {
    let len = (WIDTH * HEIGHT * 4) as usize;
    let mut rgba = Vec::with_capacity(len);
    for pixel in rgb.chunks(3) {
        for _ in 0..SCALE {
            rgba.extend_from_slice(&pixel);
            rgba.push(255);
        }
    }
    rgba
}
